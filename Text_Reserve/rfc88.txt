Мережева робоча група Р. Брейден
Запит на коментарі: 88 S. Wolfe
NIC: 5668 UCLA/CCN
                                                          13 січня 1971 року


           NETRJS - ПРОТОКОЛ ТРЕТЬОГО РІВНЯ ДЛЯ ВІДДАЛЕНОГО ВХОДУ НА РАБОТУ

    A. Вступ

    NETRJS — це назва протоколу повідомлень і набору елементів керування
    угоди, які дозволять користувачам на віддалених хостах отримувати доступ до RJS
    («Remote Job Service») віддалена пакетна підсистема CCN. RJS[1] був
    написаний на CCN для підтримки віддаленого пакетного (автомобільний зчитувач/лінійний принтер)
    термінали по лініях зв'язку.

    RJS змушує пристрої запису одиниць віддаленого пакетного терміналу працювати так, ніби
    вони були на центральному майданчику; Таким чином, віддалений користувач входить в OS/360
    завдань разом із JCL у віддалений зчитувач. Роботи є
    завантажуються в операційну систему і запускаються в свою чергу, і
    друкований та/або перфорований вихід повертається на віддалений термінал з
    з якого виникли завдання (якщо користувач або оператор не перенаправляє
    вихід). Віддалений термінал може також включати консольну друкарську машинку
    для використання віддаленим оператором для отримання та надсилання повідомлень і до
    здійснювати контроль над своїм терміналом [2].

    Коли RJS використовується через мережу ARPA, це «віддалений термінал».
    Очікується, що це буде багатопрограмований процес користувача на віддаленому хості. ми
    використовуватиме термін RJS «віддалений сайт» для такого процесу користувача, який
    імовірно імітує пристрої запису одиниць шляхом файлового введення/виведення. Крім того,
    декілька користувачів на одному віддаленому хості можуть одночасно використовувати NETRJS,
    діючи як самостійні «віддалені вузли», що виділяються 8-ма символами
    імена під назвою _terminal-ids_ (оскільки кожен віддалений сайт відображається в RJS
    як окремий фізичний термінал). Будуть дійсні ідентифікатори терміналів
    призначається окремим користувачам або групам користувачів на віддалених хостах, які бажають
    використовувати NETRJS.

    У NETRJS з цього відкривається окреме мережеве з’єднання ARPA
    віддаленого сайту до CCN для кожного (імітованого) пристрою запису одиниці. Кожен
    таке з'єднання буде називатися _каналом_ і позначатися _входом_
    або _output_ з посиланням на CCN. Ми визначаємо _стандартний_ пульт
    сайт у NETRJS має наступні п’ять каналів (див. рис. 1):

       1._Канал введення оператора_ - команди та повідомлення, які вводить
          віддалена «операторська» консоль.

       2 _Вихідний канал оператора_ - потік повідомлень, який зазвичай
          бути направлений до віддаленого оператора.



Брейден та ін. al. [Сторінка 1]

RFC 88 NETRJS - ПРОТОКОЛ ТРЕТЬОГО РІВНЯ 13 січня 1971 р.


       3._Вхідний потік_ - один імітований пристрій для зчитування карток Hollerith для роботи
          подання.

       4._Потік принтера_ - один змодельований лінійний принтер для запису на друк
          вихід (системні повідомлення та набори даних SYSOUT) із завдань.

       5._Punch Stream_ - одна імітація перфорації картки з можливістю запису
          довільний (тобто прозорий) двійковий текст.

    RJS фактично підтримуватиме більше одного зчитувача, принтера та перфоратора
    кожен віддалений термінал, щоб протокол NETRJS можна було легко розширити
    щоб дозволити декілька одночасних потоків введення-виведення для кожного користувача мережі.
    Однак наразі це не є корисним, як мережа ARPA
    пропускна здатність зазвичай є обмеженням швидкості передачі
    під NETRJS.

    У NETRJS текст одного мережевого повідомлення називається a
    _блок_. Блок має змінну довжину, до 900 байт (окрім
    блоки введення та виведення оператора, які не можуть перевищувати 130 байт).
    Тут термін _байт_ відноситься до набору з 8 бітів, що представляють один
    характер; кожен байт повинен бути вирівняний на 8-бітній межі в межах
    повідомлення (і блокування). Таким чином, ми можемо вважати блок рядком
    байтів. Детальний формат блоку буде визначено в Розділах E,
    F і G, використовуючи, по суті, формалізм, запропонований Bobrow і
    Сазерленд у RFC №31.

    Оскільки центральний хост сайту (CCN) — це IBM 360, NETRJS використовує IBM
    Символьний код EBCDIC, щоб уникнути зайвого перетворення коду в обох
    хостів у тих випадках, коли віддалений хост також використовує EBCDIC
    внутрішньо. Однак формати повідомлень не роблять жодних припущень
    код і фактично «колоди об’єктів», надіслані на (змодельовану) картку
    punch зазвичай міститиме довільний двійковий текст.

    Щоб максимізувати використання доступної пропускної здатності мережі, ми наполегливо
    рекомендувати передавати вхідні блоки якомога більшого розміру; CCN буде
    завжди повністю блокувати вихід NETRJS. Крім того, щоб уникнути надмірного
    ми закликаємо всіх користувачів NETRJS зробити позначку _a
    кратне 8 bits_, тому повідомлення, отримані в CCN, надходять на один байт
    межа.

    B. Початок сеансу[3]

    Початковий протокол підключення для NETRJS по суті є протоколом з
    Крокер у RFC #66 (як повторено Harslem і Heafner у RFC #80),
    з деякими розширеннями. Імовірно, користувач U на віддаленому хості запитує
    його оutgoing logger для підключення NETRJS до CCN. Це





Брейден та ін. al. [Сторінка 2]

RFC 88 NETRJS - ПРОТОКОЛ ТРЕТЬОГО РІВНЯ 13 січня 1971 р.


    logger робить це, спочатку надсилаючи початковий RFC для підключення до сокета
    (user,aen) = (U,s) до роз’єму CCN (0,5). Користувач 0 у CCN є
    вхідний реєстратор, а aen = 5 означає NETRJS.

    Реєстратор вхідних повідомлень CCN виділить набір із (шести) послідовних aen
    числа A, A+1,......A+5, для користувача U повертає повідомлення, що містить
    номер сокета (U,A), як зазначено в RFC #66, і закрийте ініціал
    підключення. Потім віддалені та центральні сайти відкриють вхід
    між розеткою CCN (U,A) (розетка f на малюнку 1) і дистанційним
    розетка (U, s+1). Це канал дистанційного введення оператора. The
    інші пристрої мають фіксовані aen на CCN, призначені відносно A, in
    зокрема:

                                  Розетка CCN
          Канал (користувач, aen)

          Введення оператора (U,A)
          Вихід оператора (U,A+1)
          Кардрідер (№ 1) (U,A+2)
          Принтер (№ 1) (U,A+3)
          Удар (№ 1) (U,A+5)

    Коли канал введення оператора відкрито, віддалений сайт повинен
    передати дійсне повідомлення входу RJS [2]. Це повідомлення має вільний формат
    і складається з командного дієслова "SIGNON", за яким слідує користувач
    ідентифікатор терміналу. Якщо RJS не розпізнає ідентифікатор терміналу або не має
    доступний обробник рядків для мережі, це вкаже на відмову
    закриття каналу введення оператора. Далі виникають проблеми з центральним сайтом
    RFC для інших каналів, перелічених вище, лише у відповідь на
    відповідні RFC з віддаленого сайту

    Щоб завершити сеанс, віддалений сайт може закрити вхід консолі
    каналу (гніздо «а» на малюнку 1). Крім того, користувач може ввійти
    команда SIGNOFF через канал введення оператора; в цьому випадку,
    RJS чекатиме, доки поточні вихідні потоки завдання не будуть завершені
    потім завершіть сеанс. RJS завершує сесію шляхом закриття
    вихідний канал консолі (розетка g). Крім того, якщо RJS слід припинити
    тоді сокет g закриється. Якщо будь-який сайт завершує сеанс, усі
    інші підключення для цього віддаленого сайту повинні бути закриті. Зверніть увагу, що a
    користувач може подати ряд завдань, підписатись і пізніше отримати своє
    вихід, коли він знову підпишеться.

C. Контроль каналу

    Контроль потоку в NETRJS обробляється мережевим протоколом ALL
    механізм. Перед тим, як передача потоку записів може початися на a
    конкретного каналу, віддалений сайт повинен видати RFC і Central
    повинен відповісти. Це дозволяє центральному сайту визначати віддалений



Брейден та ін. al. [Сторінка 3]

RFC 88 NETRJS - ПРОТОКОЛ ТРЕТЬОГО РІВНЯ 13 січня 1971 р.


    динамічна конфігурація. Конкретний пристрій для читання карток, принтер або
    Канал перфоратора відкритий тільки тоді, коли він активний, тому ресивер потребує
    не зв’язувати без потреби буферний простір. Кожен із цих каналів, коли
    open, припускає виділення буфера щонайменше 900 байтів у
    приймач.

    З іншого боку, канали введення та виведення оператора відкриті
    протягом усього сеансу. На цих каналах приймач повинен забезпечити
    виділення щонайменше 130 байт.

    Після надсилання команди SIGNON через канал введення оператора,
    віддалений сайт повинен надіслати RFC для всіх вихідних каналів, які готові
    для отримання даних. Коли доступний вихід для цього сайту, Central
    повертає RFC і починає передачу. Центральний закриває вихід
    канал (розетки i та j) у кінці виводу для кожного повного
    пакетне завдання.[4] Потім віддалений сайт повинен надіслати новий RFC і Central
    має відповісти RFC, щоб розпочати виведення для іншої роботи
    пристрій. Це дає можливість віддаленому сайту виділити новий файл
    для кожного завдання, не порушуючи результат роботи. Якщо користувач
    на віддаленому сайті хоче скасувати (або повернути назад або відкласти) вихід
    певної роботи, він вводить відповідні команди RJS[2] на
    канал введення оператора.

    Коли віддалений сайт готовий надіслати завдання (або стек
    послідовних завдань), він видає RFC для введення з пристрою зчитування карток
    канал. Для закриття каналу віддалений сайт не потрібен
    (розетка c) після кожного завдання в "стосі" завдань, але він повинен його закрити
    після останнього завдання в стеку, щоб розпочати його обробку.

    Сайту-одержувачу може знадобитися перервати певний
    каналу, можливо, через помилку передачі (див. розділ D нижче).
    перевірка) або помилка введення-виведення диска. Приймач може перервати канал
    (окрім консольного виведення), закривши його (сокети d, e, f і h).
    Ця дія сигналізує передавачу про повторну передачу інформації
    після того, як канал було повторно відкрито (ініційовано віддаленим сайтом, як
    завжди). З іншого боку, передавач перериває канал
    надсилання блоку з певною комбінацією бітівn (e = 2 у BCBYTE;
    див. розділ E).

    Якщо будь-який із сайтів перериває канал зчитування карток (вхід), RJS буде відхилено
    текст останньої частково запущеної роботи; віддалений сайт повинен
    повторно передати це завдання. Зауважте, що ввійде повторення всього стека
    дублікати завдань у систему, але друга копія завдання буде
    "промивання" через дублікат імені завдання.

    Якщо принтер або канал перфорації (виведення) перервано, Central повторно
    передавати з початку поточного набору даних SYSOUT; в
    ефект такий самий, як і команда RESTART.[2]



Брейден та ін. al. [Сторінка 4]

RFC 88 NETRJS - ПРОТОКОЛ ТРЕТЬОГО РІВНЯ 13 січня 1971 р.


    Якщо канал введення оператора перервано, віддалений сайт повинен повторно
    передати останній _блок_. Нарешті, вихідний канал оператора має
    умова переривання не визначена. Central ніколи не надішле переривання каналу
    повідомлення на цьому каналі; якщо віддалений сайт закриває свій сокет (socket
    b), Central не буде повторно передавати, а просто припинить надсилання повідомлень
    поки канал не буде знову відкритий. Тому може працювати віддалений сайт
    без операторського вихідного каналу; однак ми не рекомендуємо цього,
    оскільки тоді користувач пропускатиме консультаційні повідомлення оператора, такі як a
    попередження про загрозу IPL.

D. Перевірка

    Природа служби дистанційного працевлаштування така, що низька ставка
    невиявлених помилок є обов'язковим. IMP використовують CRC і послідовність
    номерів по лініях зв'язку, тому ефективна помилка IMP-IMP
    швидкість повинна бути незначною. Хоча перевірка не передбачена
    для інтерфейсу IMP-Host здається ймовірним, що ці інтерфейси
    буде або надійним, або катастрофічно вийде з ладу; це здається малоймовірним
    що відбудуться «вибої» або інші випадкові збої. Тому тільки
    передбачені такі прості перевірки:

    1. Кожен блок (принаймні спочатку) міститиме перевірку фіксованого біта
       шаблон з використанням обох станів увімкнення та вимкнення кожного бітового шляху в 16
       розрядний інтерфейс КПК у CCN.

       Передбачається, що навіть ця груба перевірка IMP-Host
       передача буде корисною як під час початкової перевірки
       обладнання та програмне забезпечення, а також пізніше, якщо стане інтерфейс
       маргінальний. Однак будь-який сайт може пропустити шаблон перевірки, якщо він
       встановлює біт у контрольний байт блоку (BCBYTE); див. розділ F.

    2. Кожен блок містить порядковий номер. Знову ж таки, це призначено для
       початкова перевірка та сигналізація про катастрофічне обладнання чи програмне забезпечення
       проблеми. Якщо приймач виявляє неправильний шаблон перевірки або
       порядковий номер блоку, він перериває канал, закриваючи
       відповідне підключення до мережі; тоді віддалений сайт повинен
       видайте RFC, щоб відновити підключення до мережі. Послідовність
       номер першого блоку після RFC дорівнює 0. Числа є
       ніколи не скидайте, коли з'єднання відкрито.












Брейден та ін. al. [Сторінка 5]

RFC 88 NETRJS - ПРОТОКОЛ ТРЕТЬОГО РІВНЯ 13 січня 1971 р.


E. Формат блоку

       БЛОК <---- БЛОК + (ЗАПИС = r) + КІНЕЦЬ БЛОКУ

                   Тут r > 0
                          =
    BLOCKHEAD <-- BCBYTE + [e=0=>CHECK] + DEVBYTE

                   Поле Blockhead складається з контрольного байта блоку,
                   32-розрядне поле перевірки CHECK і байт пристрою.

    BCBYTE <---- '1'BIT + e:ERRORCONTROL + b:BLKSEQ

                   Тут BLKSEQ містить 5-бітну послідовність блоків за модулем 32
                   число b. ERRORCONTROL — це 2-бітне поле з
                   такі значення:

                   e=0 : нормальний блок. Містить (імовірно дійсний)
                          перевірити поле ПЕРЕВІРКА.

                   e=1 : Блок не містить контрольного поля CHECK.

                   e=2 : переривання каналу, ініційоване передавачем.
                          Канали не закриваються, передача перезапускається
                          на службовому кордоні.

    DEVBYTE <---- '1'BIT + n:DEVNO + t:DEVTYPE

                   Цей байт ідентифікує певний віддалений пристрій, тобто
                   він ідентифікує потік. DEVTYPE визначає тип
                   пристрій, а саме:

                   t=1: Виведення на віддалену консоль оператора.
                     2: Введення з віддаленої консолі оператора.
                     3: Вхід із пристрою для читання карток.
                     4: Виведення на принтер.
                     5: Виведення на перфоратор картки.
                   6,7: Не використовується.

                   DEVNO — це 3-розрядне ціле число, яке ідентифікує
                   конкретний тип пристрою типу t на цьому віддаленому місці.

    ПЕРЕВІРИТИ <--- '10101111'BYTE + 01010000'BYTE + '11111010'BYTE +
                                                    '00000101'БАЙТ
    ENDOFBLOCK<----'0'BYTE






Брейден та ін. al. [Сторінка 6]

RFC 88 NETRJS - ПРОТОКОЛ ТРЕТЬОГО РІВНЯ 13 січня 1971 р.


Формат запису

       ЗАПИС <------ЗАПИС ДАНИХ | JOBNAMERECORD

    Перший запис, надісланий на принтер або канал перфорації, буде a
    JOBNAMERECORD, що визначає назву завдання OS/360 завдання, яке
    створив наступний результат.

    DATARECORD <--- '10'BIT2 + DEVCNTRL + (STRING=p) + ENDOFRECORD

    JOBNAMERECORD <-- '11000000'BYTE + '11001000'BYTE + JOBNAME +
                      ЕНДОФРЕКОРД

    НАЗВА ВАКАНСІЇ <---- (TEXTBYTE = 8)

                      Це 8-значна назва завдання OS/360 для
                      наступна робота.

    DEVCNTRL <----- d:BIT2 + k:BIT4

                      DEVCNTRL визначає керування кареткою для принтера,
                      тому, якщо пристрій не є принтером, тоді DEVCNTRL
                      має бути "000000". Для принтера:

                      d=0 : k рядків після друку; 0 < k < 3
                                                                = =
                                дозволено

                      d=2 : Відразу відставте k рядків.

                      d=1, k=1: Перейти до початку нової сторінки після друку.

                      d=3, k=1: негайно перейти до початку нової сторінки.

    STRING <--- ('100' + i:DUPCOUNT)| Це рядок i
                      послідовні прогалини.

                      ('101' + i:DUPCOUNT + TEXTBYTE)|

                      Це рядок із i послідовних дублікатів
                      TEXTBYTE.

                      ('11' + j:LENGTH + (TEXTBYTE=j)| Це
                      нестиснений рядок із j символів.

    ENDOFRECORD <---- '0'BYTE





Брейден та ін. al. [Сторінка 7]

RFC 88 NETRJS - ПРОТОКОЛ ТРЕТЬОГО РІВНЯ 13 січня 1971 р.


G. Визначення полів

    Ім'я* Значення Довжина (біт)
    _____ _______ _____________

    BIT 1-бітове поле 1

    BIT2 2-бітове поле 2

    BIT4 4-бітове поле 4

    BLKSEQ Порядковий номер блоку 5

    8-бітне поле BYTE вирівняно за 8-бітним 8
                    межа

    ЧЕК Блок чека №32

    DEVNO Номер пристрою заданого 3
                    типу

    DEVTYPE Тип пристрою 4

    DUPCOUNT Кількість реплікацій 5
                    дубльований символ в
                    стиснутий текст.

    ERRORCONTROL Помилка передачі блоку 2
                    КОНТРОЛЬ.

    LENGTH Довжина в байтах із 6
                    наступний рядок тексту.

    TEXTBYTE 8-бітний байт тексту 8

    *Примітка: усі нетермінальні поля, імена яких закінчуються на
            "...BYTE" представляє байти як довжини, так і
            вирівнювання.













Брейден та ін. al. [Сторінка 8]

RFC 88 NETRJS - ПРОТОКОЛ ТРЕТЬОГО РІВНЯ 13 січня 1971 р.


    H. ПРИМІТКИ ТА ПОСИЛАННЯ

    1. Мартин В.А. та Спрінгер, Т.В., «Реалізація віддаленої роботи
       Service", Technical Report TR2, Campus Computing Network, UCLA,
       Лос-Анджелес, (без дати).

    2. Команди та повідомлення оператора RJS детально описані в
       Посилання 1.

    3. Ми використовуємо фразу «початок сеансу», а не «вхід»
       оскільки RJS має власну процедуру входу, яка, як ми припускаємо, є a
       протокол четвертого рівня.

    4. Зауважте, що NETRJS використовує закриття з’єднань як кінець файлу
       сигнали.



            REMOTE SITE             CENTRAL SITE (CCN)
      +---------------------+    +--------------------+
      |                 a   |    |                    |
      | Console Input  o----------->o f               |
      |                 b   |    |                    |
      | Console Output o<-----------o g               |
      |                 c   |    |                    |
      | Card Reader    o------------o h               |
      |                 d   |    |                    |
      | Printer        o<-----------o i               |
      |                 e   |    |                    |
      | Card Punch     o<-----------o j               |
      |                     |    |                    |
      +---------------------+    +--------------------+
                            ФІГУРА 1
                 Мережеві підключення ARPA (канали)
               Для стандартного віддаленого сайту під NETRJS

       Р.Т. Брейден/рб.
       С.М. Вульф


            [Цей RFC було переведено в машиночитану форму для введення]
             [до онлайн-архівів RFC Лоррі Шіота, 10/01]








Брейден та ін. al. [Сторінка 9]
